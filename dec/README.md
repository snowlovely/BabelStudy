# 逆向分析

第1行是大数组，第3-7行是数组乱序还原代码，可以看出使用了数组混淆

第3-7行定义的`_0x524cab`函数真正的执行是在41行的`_0x3d1943`

第8-59行定义的`_0x4821c6`函数是在第60行执行

第9-44行定义的`_0x398fd3`是一个大对象，在第49行调用了45-48行的`_0xef60f0`函数保存至`_0x398fd3['updateCookie']`，在第51行做了真正的调用，返回`_0x4e6c47`，在52-58行做了判断

注意`_0x398fd3`的函数`removeCookie`调用`toString`函数的情况，返回结果是被格式化后的整个代码块，无法匹配到`_0x4ba6f5`的正则，所以一定进入53行，正常情况不做格式化情况下进入55行。跟入错误路径，到达14-29行`_0x4ba6f5`，分析18-27行的for循环，这里是死循环

进入正常流程`getCookie`分析，第34-37行是简单的花指令让进行正则实例化，第38-41调用了大数组的还原函数

从63-132行定义了`_0x2ba9`大函数，在64行做强转，在65行从大数组中取出赋值给`_0x27941a`

注意到66行的判断条件在94行被改为true，所以66-95行的作用是初始化。在69-74行得到window对象。其中75-82行是Base64解码函数，如果不能使用atob函数那么就会调用自己实现的函数

在85行定义的函数在126行被调用，猜测`_0x2ba9['dzoqWA']`是解密函数

93行定义的`_0x2ba9['nKWcry']`在96行尝试获取，猜测是保存已经解密后的结果，不再重复调用。127行将解密后结果保存在`_0x2ba9['nKWcry']`中，所以相同解密结果第二次走到96行时候，会进入129行直接赋值，最终在131行返回

第125行调用了107行的函数，比较容易观察出107到111行做了格式化验证，非正常情况最终跟入118-124行死循环

中间部分是业务代码，992行是流程平坦化
